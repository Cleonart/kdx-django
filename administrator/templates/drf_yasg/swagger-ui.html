{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ title }}</title>
    
    <!-- Swagger UI CSS -->
    <link
      rel="stylesheet"
      type="text/css"
      href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css"
    />
    
    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/favicon-32x32.png"
      sizes="32x32"
    />
    
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          'Helvetica Neue', Arial, sans-serif;
        overflow: hidden;
        margin: 0;
      }

      /* Hide default Swagger UI elements */
      .swagger-ui .topbar,
      .swagger-ui .information-container,
      .swagger-ui .scheme-container {
        display: none !important;
      }

      .swagger-ui .wrapper {
        padding: 0;
      }

      /* Main Layout */
      #app {
        display: flex;
        height: 100vh;
        overflow: hidden;
      }

      /* Sidebar Styles */
      .api-sidebar {
        width: 280px;
        background: #1a1a1a;
        color: #fff;
        overflow-y: auto;
        flex-shrink: 0;
      }

      .sidebar-header {
        padding: 24px 20px;
        border-bottom: 1px solid #333;
      }

      .sidebar-header h1 {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .sidebar-header p {
        font-size: 13px;
        color: #999;
      }

      .sidebar-search {
        padding: 16px 20px;
        border-bottom: 1px solid #333;
      }

      .sidebar-search input {
        width: 100%;
        padding: 10px 12px;
        background: #2a2a2a;
        border: 1px solid #404040;
        border-radius: 6px;
        color: #fff;
        font-size: 14px;
      }

      .sidebar-search input::placeholder {
        color: #777;
      }

      .sidebar-search input:focus {
        outline: none;
        border-color: #ff6b35;
      }

      .sidebar-nav {
        padding: 12px 0;
      }

      .nav-category {
        margin-bottom: 4px;
      }

      .category-header {
        padding: 10px 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
        font-weight: 600;
        color: #999;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        transition: all 0.2s;
      }

      .category-header:hover {
        color: #fff;
        background: #2a2a2a;
      }

      .category-header.active {
        color: #fff;
      }

      .category-arrow {
        transition: transform 0.2s;
        font-size: 10px;
      }

      .category-header.active .category-arrow {
        transform: rotate(90deg);
      }

      .category-endpoints {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .category-endpoints.show {
        max-height: 3000px;
      }

      .endpoint-item {
        padding: 10px 20px 10px 36px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 13px;
        transition: all 0.2s;
        border-left: 3px solid transparent;
        color: #ccc;
      }

      .endpoint-item:hover {
        background: #2a2a2a;
        color: #fff;
      }

      .endpoint-item.active {
        background: #2a2a2a;
        border-left-color: #ff6b35;
        color: #fff;
      }

      .endpoint-method {
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        flex-shrink: 0;
      }

      .method-get { background: #61affe; color: #fff; }
      .method-post { background: #49cc90; color: #fff; }
      .method-put { background: #fca130; color: #fff; }
      .method-patch { background: #50e3c2; color: #fff; }
      .method-delete { background: #f93e3e; color: #fff; }
      .method-head { background: #9012fe; color: #fff; }
      .method-options { background: #0d5aa7; color: #fff; }

      .endpoint-name {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Main Content */
      .api-content {
        flex: 1;
        display: flex;
        overflow: hidden;
      }

      .content-documentation {
        flex: 1;
        background: #fafafa;
        overflow-y: auto;
      }

      .content-tryout {
        width: 45%;
        background: #252525;
        overflow-y: auto;
        border-left: 1px solid #333;
      }

      .tryout-container {
        padding: 20px 15px;
        color: #fff;
      }

      .tryout-header {
        margin-bottom: 24px;
      }

      .tryout-header h3 {
        font-size: 18px;
        margin-bottom: 10px;
        font-weight: 600;
      }

      .endpoint-display {
        background: #2a2a2a;
        padding: 7px 6px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .endpoint-path {
        font-family: monospace;
        font-size: 14px;
      }

      .empty-state {
        padding: 40px 32px;
        text-align: center;
      }

      .empty-state h3 {
        font-size: 18px;
        margin-bottom: 16px;
        color: #999;
      }

      .empty-state p {
        font-size: 14px;
        color: #666;
      }

      /* Category Header */
      .category-header-banner {
        padding: 16px 20px;
        background: #fff;
        border-bottom: 2px solid #ff6b35;
        font-size: 14px;
        font-weight: 600;
        color: #333;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        position: sticky;
        top: 0;
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      /* Ensure operations don't hide under banner */
      .swagger-ui .opblock:first-of-type {
        margin-top: 0;
      }

      .swagger-ui .opblock-description-wrapper {
        margin-top: 0;
        padding: 9px 0px;
      }

      .swagger-ui .table-container {
        padding-bottom: 0px;
      }

      .swagger-ui .opblock.is-open {
        scroll-margin-top: 70px;
      }

      /* Hide operations by default */
      .swagger-ui .opblock {
        display: none;
      }

      .swagger-ui .opblock[style*='display: block'] {
        display: block !important;
        margin-bottom: 15px;
      }

      /* Swagger UI customizations */
      .swagger-ui .opblock-tag {
        display: none !important;
      }

      .swagger-ui .opblock {
        border: none;
        box-shadow: none;
        margin: 0 0 2px 0;
        background: transparent;
      }

      .swagger-ui .opblock .opblock-summary {
        border: none;
        padding: 12px 20px;
        background: #fff;
        border-bottom: 1px solid #e1e4e8;
      }

      .swagger-ui .opblock-body {
        padding: 0px 20px;
        background: #fff;
      }

      .swagger-ui .btn.execute {
        background: #ff6b35;
        border-color: #ff6b35;
      }

      .swagger-ui .btn.execute:hover {
        background: #ff5722;
        border-color: #ff5722;
      }

      /* Right panel dark theme */
      #tryout-panel .swagger-ui input,
      #tryout-panel .swagger-ui textarea,
      #tryout-panel .swagger-ui select {
        background: #1a1a1a !important;
        color: #fff !important;
        border: 1px solid #404040 !important;
      }

      #tryout-panel .swagger-ui table thead tr th {
        background: #1a1a1a !important;
        color: #999 !important;
      }

      #tryout-panel .swagger-ui table tbody tr td {
        background: transparent !important;
        color: #ccc !important;
      }

      #tryout-panel .swagger-ui .responses-inner {
        background: #1e1e1e !important;
      }

      /* Scrollbar */
      .api-sidebar::-webkit-scrollbar,
      .content-documentation::-webkit-scrollbar,
      .content-tryout::-webkit-scrollbar {
        width: 8px;
      }

      .api-sidebar::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 4px;
      }

      .content-documentation::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 4px;
      }

      .content-tryout::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 4px;
      }

      /* Responsive */
      @media (max-width: 768px) {
        #app {
          flex-direction: column;
        }

        .api-sidebar {
          width: 100%;
          height: 40vh;
        }

        .api-content {
          flex-direction: column;
        }

        .content-documentation,
        .content-tryout {
          width: 100%;
        }
      }

      /* Make each operation body a 2-column grid */
      .swagger-ui .opblock-body {
        display: grid;
        grid-template-columns: 1fr 1fr;           /* left/right */
        grid-template-areas:
          "desc desc"                             /* description full width */
          "params responses"                      /* split */
          "exec responses";                       /* keep responses visible while executing */
        gap: 16px;
        align-items: start;
      }

      /* Description stays full width on top */
      .swagger-ui .opblock-body > .opblock-description-wrapper {
        grid-area: desc;
      }

      /* Parameters (table) → left column */
      .swagger-ui .opblock-body > .opblock-section:has(.parameters-container),
      .swagger-ui .opblock-body > .opblock-section:has(table.parameters),
      .swagger-ui .opblock-body > .opblock-section.request-body {
        grid-area: params;
      }

      /* Execute button wrapper under parameters (left) */
      .swagger-ui .opblock-body > .execute-wrapper {
        grid-area: exec;
        padding: 8px 30px;
      }

      .swagger-ui .opblock-body > .btn-group {
        grid-area: exec;
        padding: 8px 30px;
      }

      /* Responses → right column */
      .swagger-ui .opblock-body > .responses-wrapper,
      .swagger-ui .opblock-body > .opblock-section.responses-wrapper {
        grid-area: responses;
        max-height: 85vh !important;
        overflow: auto;
        position: sticky; top: 0;                 /* optional: keep visible while scrolling left */
      }

      /* Optional: tidy visuals */
      .swagger-ui .opblock-section,
      .swagger-ui .responses-wrapper {
        background: #fff;
        border-radius: 6px;
        box-sizing: border-box;
      }
      
      .swagger-ui .parameters-col_description{
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- Sidebar -->
      <aside class="api-sidebar">
        <div class="sidebar-header">
          <h1>{% verbatim %}{{ appTitle }}{% endverbatim %}</h1>
          <p>{% verbatim %}{{ appDescription }}{% endverbatim %}</p>
        </div>

        <div class="sidebar-search">
          <input
            type="text"
            v-model="searchQuery"
            placeholder="Search endpoints..."
          />
        </div>

        <nav class="sidebar-nav">
          <div
            v-for="(endpoints, tag) in filteredCategories"
            :key="tag"
            class="nav-category"
          >
            <div
              class="category-header"
              :class="{ active: activeCategory === tag }"
              @click="selectCategory(tag)"
            >
              <span>{% verbatim %}{{ tag }}{% endverbatim %}</span>
              <span class="category-arrow">▶</span>
            </div>
            <div
              class="category-endpoints"
              :class="{ show: activeCategory === tag }"
            >
              <div
                v-for="endpoint in endpoints"
                :key="endpoint.path + endpoint.method"
                class="endpoint-item"
                :class="{ active: isActiveEndpoint(endpoint) }"
                @click="selectEndpoint(endpoint)"
              >
                <span
                  class="endpoint-method"
                  :class="'method-' + endpoint.method.toLowerCase()"
                >
                  {% verbatim %}{{ endpoint.method }}{% endverbatim %}
                </span>
                <span class="endpoint-name">{% verbatim %}{{ endpoint.summary }}{% endverbatim %}</span>
              </div>
            </div>
          </div>
        </nav>
      </aside>

      <!-- Main Content -->
      <main class="api-content">
        <!-- Documentation Panel -->
        <div class="content-documentation">
          <div v-if="activeCategory" class="category-header-banner">
            <span style="font-size: 16px">📁</span>
            <span>{% verbatim %}{{ activeCategory }}{% endverbatim %}</span>
          </div>
          <div id="swagger-ui"></div>
        </div>
        </div>
      </main>
    </div>

    <!-- Vue.js 3 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js"></script>
    
    <!-- Swagger UI -->
    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>

    <script>
      const { createApp, ref, computed, onMounted, nextTick } = Vue;

      createApp({
        setup() {
          // ============================================
          // STATE
          // ============================================
          const appTitle = ref('{{ title|escapejs }}');
          const appDescription = ref('{{ description|escapejs }}');
          const apiSpec = ref(null);
          const categories = ref({});
          const searchQuery = ref('');
          const activeCategory = ref(null);
          const selectedEndpoint = ref(null);
          const swaggerUI = ref(null);

          // ============================================
          // COMPUTED
          // ============================================
          
          /**
           * Filter categories based on search query
           */
          const filteredCategories = computed(() => {
            if (!searchQuery.value) {
              return categories.value;
            }

            const query = searchQuery.value.toLowerCase();
            const filtered = {};

            Object.keys(categories.value).forEach((tag) => {
              const matchingEndpoints = categories.value[tag].filter(
                (endpoint) => {
                  const searchText = `${endpoint.method} ${endpoint.path} ${endpoint.summary}`.toLowerCase();
                  return searchText.includes(query);
                }
              );

              if (matchingEndpoints.length > 0) {
                filtered[tag] = matchingEndpoints;
              }
            });

            return filtered;
          });

          // ============================================
          // METHODS
          // ============================================

          /**
           * Initialize Swagger UI
           */
          const initSwagger = () => {
            swaggerUI.value = SwaggerUIBundle({
              url: '{% url "schema-json" %}',
              dom_id: '#swagger-ui',
              deepLinking: true,
              presets: [
                SwaggerUIBundle.presets.apis,
                SwaggerUIStandalonePreset,
              ],
              plugins: [SwaggerUIBundle.plugins.DownloadUrl],
              layout: 'BaseLayout',
              defaultModelsExpandDepth: 1,
              defaultModelExpandDepth: 1,
              docExpansion: 'list',
              onComplete: () => {
                setTimeout(() => {
                  loadApiSpec();
                }, 1000);
              },
            });
          };

          /**
           * Load and parse API specification
           */
          const loadApiSpec = () => {
            try {
              const spec = swaggerUI.value.specSelectors.spec().toJS();
              apiSpec.value = spec;
              parseEndpoints(spec);

              // Select first category by default
              const firstCategory = Object.keys(categories.value)[0];
              if (firstCategory) {
                selectCategory(firstCategory);
              }
            } catch (error) {
              console.error('Error loading API spec:', error);
            }
          };

          /**
           * Parse endpoints from OpenAPI spec
           */
          const parseEndpoints = (spec) => {
            const paths = spec.paths || {};
            const cats = {};

            Object.keys(paths).forEach((path) => {
              Object.keys(paths[path]).forEach((method) => {
                if (method === 'parameters') return;

                const operation = paths[path][method];
                const tag = (operation.tags && operation.tags[0]) || 'default';

                if (!cats[tag]) {
                  cats[tag] = [];
                }

                cats[tag].push({
                  path: path,
                  method: method.toUpperCase(),
                  summary: operation.summary || operation.operationId || path,
                  operationId: operation.operationId,
                  tag: tag,
                });
              });
            });

            categories.value = cats;
          };

          /**
           * Select a category
           */
          const selectCategory = (tag) => {
            activeCategory.value = tag;
            selectedEndpoint.value = null;
            filterOperationsByTag(tag);
          };

          /**
           * Select an endpoint
           */
          const selectEndpoint = (endpoint) => {
            selectedEndpoint.value = endpoint;

            nextTick(() => {
              openOperation(endpoint);
            });
          };

          /**
           * Check if endpoint is active
           */
          const isActiveEndpoint = (endpoint) => {
            return (
              selectedEndpoint.value &&
              selectedEndpoint.value.path === endpoint.path &&
              selectedEndpoint.value.method === endpoint.method
            );
          };

          /**
           * Filter operations by tag
           */
          const filterOperationsByTag = (tag) => {
            const allOperations = document.querySelectorAll('.opblock');

            allOperations.forEach((operation) => {
              const operationTag = findOperationTag(operation);

              if (operationTag === tag) {
                operation.style.display = 'block';
              } else {
                operation.style.display = 'none';
                operation.classList.remove('is-open');
              }
            });
          };

          /**
           * Find operation tag
           */
          const findOperationTag = (operation) => {
            const pathElement = operation.querySelector('.opblock-summary-path');
            const methodClass = operation.className.match(/opblock-(\w+)/)?.[1];

            if (pathElement && methodClass) {
              const path = pathElement.textContent.trim();
              const method = methodClass.toUpperCase();

              for (const [tag, endpoints] of Object.entries(categories.value)) {
                const found = endpoints.find(
                  (e) =>
                    (e.path === path ||
                      e.path.replace(/\/$/, '') === path.replace(/\/$/, '')) &&
                    e.method === method
                );
                if (found) return tag;
              }
            }

            return 'default';
          };

          /**
           * Open and populate operation
           */
          const openOperation = (endpoint) => {
            const operation = findOperationElement(
              endpoint.method.toLowerCase(),
              endpoint.path
            );

            if (!operation) {
              console.error('Operation not found in DOM');
              return;
            }

            // Close all other operations
            document.querySelectorAll('.opblock').forEach((op) => {
              if (op !== operation) {
                op.classList.remove('is-open');
              }
            });

            // Open the operation
            if (!operation.classList.contains('is-open')) {
              const summary = operation.querySelector('.opblock-summary');
              if (summary) summary.click();
            }

            let operationId = 'operations-' + endpoint.tag + '-' + endpoint.operationId;
            const op = document.getElementById(operationId);
            if (op) {
              const btn = op.querySelector('.opblock-summary-control');
              if (btn && btn.ariaExpanded === 'false') {
                btn.click();
              }
            }

            // Scroll to operation with offset for sticky header
            setTimeout(() => {
              const categoryBanner = document.querySelector('.category-header-banner');
              const bannerHeight = categoryBanner ? categoryBanner.offsetHeight : 0;
              
              const operationTop = operation.getBoundingClientRect().top;
              const scrollContainer = document.querySelector('.content-documentation');
              const currentScroll = scrollContainer.scrollTop;

              // Scroll with offset for banner
              scrollContainer.scrollTo({
                top: currentScroll + operationTop - bannerHeight - 20,
                behavior: 'smooth'
              });
            }, 100);
          };

          /**
           * Find operation element in DOM
           */
          const findOperationElement = (method, path) => {
            const allOperations = document.querySelectorAll('.opblock');

            for (let op of allOperations) {
              if (!op.classList.contains(`opblock-${method}`)) continue;

              const pathElement = op.querySelector('.opblock-summary-path');
              if (pathElement) {
                const opPath = pathElement.textContent.trim();
                if (
                  opPath === path ||
                  opPath.replace(/\/$/, '') === path.replace(/\/$/, '')
                ) {
                  return op;
                }
              }
            }

            return null;
          };

          /**
           * Populate right panel with operation details
           */
          const populateRightPanel = (operation) => {
            const container = document.getElementById('right-panel-content');
            if (!container) return;

            // Clear existing content except header
            const header = container.querySelector('.tryout-header');
            container.innerHTML = '';
            if (header) container.appendChild(header);

            // Add parameters
            const parametersContainer = operation.querySelector(
              '.parameters-container'
            );
            if (parametersContainer) {
              addSection(container, 'Parameters', parametersContainer);
            }

            // Add request body
            const requestBody = operation.querySelector('.body-param');
            if (requestBody) {
              addSection(container, 'Request Body', requestBody);
            }

            // Add execute button
            const executeWrapper = operation.querySelector('.execute-wrapper');
            if (executeWrapper) {
              const clone = executeWrapper.cloneNode(true);
              const originalBtn = executeWrapper.querySelector('.execute');
              const clonedBtn = clone.querySelector('.execute');

              if (originalBtn && clonedBtn) {
                clonedBtn.addEventListener('click', () => originalBtn.click());
              }

              container.appendChild(clone);
            }
          };

          /**
           * Add a section to right panel
           */
          const addSection = (container, title, element) => {
            const section = document.createElement('div');
            section.style.cssText = 'margin-bottom: 24px;';
            section.innerHTML = `<h4 style="font-size: 16px; margin-bottom: 16px; color: #fff; font-weight: 600;">${title}</h4>`;

            const clone = element.cloneNode(true);
            syncInputs(element, clone);

            section.appendChild(clone);
            container.appendChild(section);
          };

          /**
           * Sync inputs between original and clone
           */
          const syncInputs = (original, clone) => {
            const originalInputs = original.querySelectorAll(
              'input, textarea, select'
            );
            const clonedInputs = clone.querySelectorAll(
              'input, textarea, select'
            );

            originalInputs.forEach((originalInput, index) => {
              const clonedInput = clonedInputs[index];
              if (!clonedInput) return;

              clonedInput.value = originalInput.value;

              // Sync clone to original
              ['input', 'change'].forEach((event) => {
                clonedInput.addEventListener(event, () => {
                  originalInput.value = clonedInput.value;
                  originalInput.dispatchEvent(
                    new Event(event, { bubbles: true })
                  );
                });
              });

              // Sync original to clone
              ['input', 'change'].forEach((event) => {
                originalInput.addEventListener(event, () => {
                  clonedInput.value = originalInput.value;
                });
              });
            });
          };

          /**
           * Monitor for responses
           */
          const monitorResponses = (operation) => {
            const container = document.getElementById('right-panel-content');
            const responsesWrapper = operation.querySelector(
              '.responses-wrapper'
            );

            if (!container || !responsesWrapper) return;

            const observer = new MutationObserver(() => {
              const responsesInner = responsesWrapper.querySelector(
                '.responses-inner'
              );

              if (responsesInner && responsesInner.children.length > 0) {
                // Remove existing response
                const existingResponse = container.querySelector(
                  '.responses-wrapper'
                );
                if (existingResponse) existingResponse.remove();

                // Add new response
                const section = document.createElement('div');
                section.style.cssText = 'margin-top: 24px;';
                section.innerHTML =
                  '<h4 style="font-size: 16px; margin-bottom: 16px; color: #fff; font-weight: 600;">Response</h4>';
                section.appendChild(responsesWrapper.cloneNode(true));

                container.appendChild(section);

                setTimeout(() => {
                  section.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                  });
                }, 100);
              }
            });

            observer.observe(responsesWrapper, {
              childList: true,
              subtree: true,
            });
          };

          // ============================================
          // LIFECYCLE
          // ============================================
          
          onMounted(() => {
            initSwagger();
          });

          // ============================================
          // RETURN (EXPOSE TO TEMPLATE)
          // ============================================
          
          return {
            // State
            appTitle,
            appDescription,
            searchQuery,
            activeCategory,
            selectedEndpoint,
            
            // Computed
            filteredCategories,
            
            // Methods
            selectCategory,
            selectEndpoint,
            isActiveEndpoint,
          };
        },
      }).mount('#app');
    </script>
  </body>
</html>